# 基础知识

#### 标识符

标识符用于命名变量、函数、类、模块等对象。其命名规则如下：

*   只能包含字母、数字、下划线及各语言支持的文字字符。
    
*   不能使用保留字。
    
*   大小写严格区分。
    

#### 保留字

以下是Python的保留字（关键字），它们具有特殊的语法意义，不可用作标识符：

```python
False, None, True, and, as, assert, async, await, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield
```

#### 变量命名规范

变量名应遵循以下规范：

*   只能包含字母、数字和下划线。
    
*   不能以数字开头，也不能是纯数字。
    

#### 常见数据类型

常见的数据类型包括：

*   `int`：整数型
    
*   `float`：浮点型（注意：浮点型在进行算术运算时可能出现精度误差）
    
*   `str`：字符串
    
*   `bool`：布尔类型（只有 `True` 和 `False` 两个值，且可以分别作为 `1` 和 `0` 参与算术运算）
    

#### 类型转换

可以通过以下函数进行不同类型之间的转换：

*   `str()`：将其他类型转换为字符串
    
*   `int()`：将其他类型转换为整数
    
*   `float()`：将其他类型转换为浮点数
    

![image.png](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/cc92d43bd78d430f81eb141c8a966007/image.png)![image.png](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/e29fcc41615448068eb0dadfa47c34fe/image.png)

### 注释

*   单行注释：`#`
    
*   多行注释：`''' ... '''`
    

# 运算符

### 算术运算符

![image](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/337d83c7c59148249227f9e89afc7760/image.png)

向下取整是指取比商小的整数（例如，-2.2 取 -3，2.2 取 2）。

### 赋值运算符

*   `=`：将数据赋给变量。
    
*   **执行顺序**：从右到左。
    
*   **链式赋值**：将一个值赋给多个变量（例如，`a = b = c = 20`）。
    
*   **参数赋值**：
    
    *   `+=`：`a += 30` 即 `a = a + 30`
        
    *   `-=`：`a -= 30` 即 `a = a - 30`
        
    *   `*=`：`a *= 30` 即 `a = a * 30`
        
    *   `/=`：`a /= 30` 即 `a = a / 30`
        
    *   `//=`：`a //= 30` 即 `a = a // 30`
        
    *   `%=`：`a %= 30` 即 `a = a % 30`
        
*   **系列解包**：`a, b, c = 20, 30, 40`（将数值分别赋予变量，要求顺序和数据数量与变量一致）。
    

### 比较运算符

*   `>`、`<`、`<=`、`>=`、`==`、`!=`：对变量的值进行比较，判断条件，返回布尔类型。
    
*   `is` 和 `is not`：比较变量的标识（即内存地址）。
    

注释：`!=` 表示不等于，`==` 表示等于。

### 布尔运算符

*   `and`（并且）、`or`（或）、`not`（取反）、`in`（在...中）、`not in`（不在...中）
    

示例：`print(1 == 0 or 2 == 2)` 输出 `True`

注意：`in` 和 `not in` 区分大小写。

![image](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/d9f3b591bdc44cb5abc0076286fc4493/image.png)

### 位运算符

*   **位与** (`&`)：将数据转换成二进制，按位比较。若某一位置的两个数都为 1，则结果为 1，否则为 0。可用于判断奇偶性。
    
*   **位或** (`|`)：将数据转换成二进制，按位比较。若某一位置的两个数都为 0，则结果为 0，否则为 1。
    
*   **左移位** (`<<`)：效果相当于乘以 \\(2^n\\)。
    
*   **右移位** (`>>`)：效果相当于除以 \\(2^n\\) 并向下取整。
    

![image](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/235b695f343640e5a9fdf1ebf1fd54ee/image.png)

### 运算符优先级

运算符优先级从高到低依次为：算术运算 > 位运算 > 比较运算 > 布尔运算。

![image](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/a875e9ce53c44294a2a2dbd9cadfca3f/image.png)

### 对象的布尔值

Python 中一切对象都有布尔值，除非是以下几种情况，否则都是 `True`：

*   `False`
    
*   数值 `0`
    
*   `None`
    
*   空字符串 `""`
    
*   空列表 `[ ]`
    
*   空字典 `{}`
    
*   空元组 `()`
    
*   空集合 `set()`
    

### 序列类型

*   **可变序列**：可以直接对原对象进行增删改操作，无需创建新对象。
    
*   **不可变序列**：不能直接修改，需创建新对象。不可变序列具有更高的数据安全性，且在多线程环境中无需为数据上锁，因此在程序中应尽量使用不可变序列。
    

# 基础函数

#### `print`：打印（输出）指定内容，可输出到文件中

格式：`print()`

括号中可以进行算术运算和不同对象的连接，并将结果输出。

输出至文件示例：

```python
fp = open('D:/text.txt', 'a+')
print('helloworld', file=fp)
fp.close()
```

注释：

*   `'a+'`：以读写方式打开文件，如果文件不存在则创建；如果文件存在，则在原有内容上追加。
    
*   注意：1. 指定的盘符必须存在。2. 使用 `file=fp`（创建的文件对象）。3. 每次执行完 `print` 自动换行，`print()` 可用于换行。
    

#### `chr`：将输入的二进制字符编码转换为对应字符

示例：

```python
print(chr(0b100111001011000))  # 输出：乘
```

#### `ord`：将输入的字符转换为对应的十进制字符编码

示例：

```python
print(ord('乘'))  # 输出：20056
```

#### `type`：查找变量的数据类型

#### `input`：将键盘输入的内容赋给目标变量

格式：`input('提示语')` 示例：

```python
a = input('请输入数字')
print(a)  # 输出：456
```

#### `bool`：查询对象的布尔值

格式：`bool()`

#### `range`：用于生成一个整数序列

优点：无论表示的序列多长，所占的内存空间相同，只保存序列的开始位置、序列长度和步长三个信息。序列中的数值是在运行过程中计算出来的，而非直接保存一串数字，节省内存。 格式：`range(start, stop, step)`

*   若只填一个数，默认表示 `stop`。
    
*   若填两个数，前者表示 `start`，后者表示 `stop`。
    
*   三个数时，最后一个为 `step`。 注意：没有 `start` 默认从零开始，步长默认为 1。 示例：
    

```python
print(list(range(1, 5)))  # 输出：[1, 2, 3, 4]
```

即包括 `start`，不包括 `stop`（左闭右开 `[)`）。

#### `dir()`：内置函数，查看指定对象的属性

#### `endswith()`：判断字符串是否以特定后缀结尾

若对象的结尾与括号中一致，则返回 `True`，否则返回 `False`。 示例：

```python
if file.endswith('.py'):  # 当 `file` 这个字符串以 `.py` 结尾时
```

#### 转义字符与原字符

*   换行：`\n`
    
*   回车：`\r`（使光标退回到本行首位，覆盖前面的内容）
    
*   水平制表符：`\t`
    
*   退格：`\b`（使光标向前退一格，覆盖前一位）
    
*   反斜杠：`\\`（用两个反斜杠表示一个）
    
*   单引号：`\'`
    
*   双引号：`\"`
    

示例：

```python
print('hello\bworld')  # 输出：hellworld
print('hell\\\\ow\\\\\\\\orld')  # 输出：hell\\ow\\\\orld
```

原字符：在要输出的内容前加 `R` 或 `r`，使此字符中的转义字符失效。 注意：最后一个字符不能为单个反斜杠。 示例：

```python
print(r'hello\nworld')  # 输出：hello\nworld
```

### 分支结构

#### 单分支结构

```python
a = 500
if a == 600:
    print(a)  # 缩进表示在 `if` 结构中
```

#### 双分支结构

```python
a = int(input('请输入整数'))
if a % 2 == 0:
    print(a, '是偶数')
else:  # 记得写冒号
    print(a, '是奇数')  # 记得缩进
```

#### 多分支结构

```python
if ...:
    print()
elif ...:
    print()
elif ...:
    print()
else:  # `else` 可有可无
    print()
```

小技巧：嵌套 `if` 结构

条件表达式：`x if 判断条件 else y`（若判断为 `True` 则执行 `x`，否则执行 `y`）

```python
a = int(input('输入第一个整数'))
b = int(input('输入第二个整数'))
print(str(a), '大于等于', str(b) if a >= b else str(a), '小于等于', str(b))
```

#### `pass` 语句：用于在需要语句的地方填充，作为占位符，从而在没有内容的情况下结构正常搭建

# 循环结构

#### `while` 循环

`while` 语句用于在条件为 `True` 时重复执行一段代码块。

**格式：**

```python
while 条件表达式:
    # 循环体（记得缩进）
```

#### `for` 循环

`for` 循环用于遍历可迭代对象中的元素，如字符串、列表、元组、字典或 `range()`。

**格式：**

```python
for 自定义变量 in 可迭代对象:
    # 循环体（记得缩进）
```

如果循环体中不需要使用自定义变量，可以用下划线 `_` 代替。

**示例：**

```python
for _ in range(5):
    print("Hello")
```

#### 控制语句

*   `**break**`：立即退出当前循环。
    
*   `**continue**`：跳过当前循环的剩余部分，直接进入下一次循环。
    
*   `**else**`：当循环正常结束（即没有遇到 `break`）时执行 `else` 块中的代码。
    

**示例：**

```python
for i in range(5):
    if i == 3:
        break
    print(i)
else:
    print("循环正常结束")
```
---

# 列表

#### 存储方式

列表存储的是对象的引用（ID），而不是对象本身。通过这些引用可以访问和操作列表中的各个元素。

#### 特点

*   **可变性**：可以修改其中的元素。
    
*   **有序性**：元素按插入顺序排列。
    

#### 创建方式

1.  使用中括号 `[ ]`：
    

```python
my_list = ['hello', 'world', 12]
```

2.  使用内置函数 `list()`：
    

```python
my_list = list(['hello', 'world', 12])
```

#### 查询列表对象

1.  **获取指定元素的索引**：
    
    *   使用 `index()` 方法返回指定元素的索引。
        
    *   限定范围查询：
        
2.  **获取列表中的单个元素**：
    
    *   通过索引访问元素：
        
3.  **获取多个元素**（切片）：
    
    *   格式：`list[start:stop:step]`
        

#### 元素操作

*   **判断元素是否在列表中**：
    
    *   使用 `in` 和 `not in` 关键字：
        
*   **遍历列表元素**：
    
    *   使用 `for` 循环遍历：
        
*   **增添元素**：
    
    *   `append()`：向列表末尾添加一个元素。
        
    *   `extend()`：向列表末尾一次性添加多个元素。
        
    *   `insert()`：在指定位置插入一个元素。
        
*   **删除元素**：
    
    *   `remove()`：移除指定值的第一个匹配项。
        
    *   `pop()`：移除并返回指定索引的元素，默认移除最后一个元素。
        
    *   切片删除：用空列表替换指定范围内的元素。
        
*   **清除所有元素**：
    
    *   `clear()`：
        
*   **删除整个列表对象**：
    
    *   `del`：
        
*   **修改指定元素**：
    
    *   直接赋值：
        
*   **修改多个元素**（切片）：
    
    *   使用切片赋值：
        

#### 排序

*   `**sort()**`：原地排序，不创建新列表。
    

```python
my_list.sort()  # 升序排序
my_list.sort(reverse=True)  # 降序排序
```

*   `**sorted()**`：返回一个新的已排序列表。
    

```python
new_list = sorted(my_list)  # 升序排序
new_list = sorted(my_list, reverse=True)  # 降序排序
```

#### 列表生成式

用于简洁地生成列表，适用于有规律的数列。

**格式：**

```python
my_list = [i for i in range(1, 11)]  # 生成1到10的列表
my_list = [i * i for i in range(1, 11)]  # 生成平方数列
```

**简略版：**

```python
my_list = list(range(1, 11))
```

# 字典

字典是一种可变且无序的序列，通过哈希函数存储值，并通过计算查找值的位置来提高查找效率。其形式为：`{键: 值, 键: 值}`。

*   **特点**：
    
    *   所有键不允许相同，但值可以相同。
        
    *   空间大小可以动态伸缩。
        
    *   字典会占用较大空间，以空间换取更高的计算效率。
        
*   **键值对**：
    
    *   每个键对应一个值，通过键来查找值，类似于列表的索引。
        
    *   键必须是不可变类型（如字符串、整数）。
        

#### 创建方式

1.  使用花括号 `{}` 创建字典：
    

```python
d = {'张三': 123, 752: 523}
```

键值对之间用逗号隔开。

2.  使用内置函数 `dict()` 创建字典：
    

```python
scores = dict(name='张三', age=18)
```

使用 `dict()` 创建时，键值对以赋值的形式书写，字符串无需加引号。

3.  使用 `{}` 直接创建空字典：
    

```python
empty_dict = {}
```

#### 获取字典元素

1.  使用方括号 `[ ]` 获取值：
    

```python
value = d['张三']
```

如果输入的键不存在，将抛出 `KeyError` 异常。

2.  使用 `get()` 方法获取值：
    

```python
value = scores.get('name')
```

如果键不存在，则返回 `None`。也可以指定默认返回值：

```python
value = scores.get('home', 45)
```

#### 键的判断

使用 `in` 和 `not in` 判断指定键是否存在于字典中：

```python
'张三' in d  # 存在时返回 True，否则返回 False
```

#### 元素删除

使用 `del` 删除指定键的元素：

```python
del scores['name']
```

清空字典：

```python
scores.clear()
```

#### 添加和修改元素

添加或修改元素：

```python
scores['王五'] = 120  # 添加新键值对
scores['王五'] = 100  # 修改现有键的值
```

#### 获取键、值和键值对视图

*   获取键视图：
    

```python
keys = scores.keys()  # 返回类型为 dict_keys
list(keys)  # 转换为列表
```

*   获取值视图：
    

```python
values = scores.values()  # 返回类型为 dict_values
list(values)  # 转换为列表
```

*   获取键值对视图：
    

```python
items = scores.items()  # 返回类型为 dict_items
list(items)  # 转换为列表，其中每个元素为元组
```

#### 遍历字典

遍历字典中的键：

```python
for key in scores:
    print(key)
```

若需输出值：

```python
print(scores[key])  # 或 print(scores.get(key))
```

#### 字典生成式

使用字典生成式创建字典：

```python
{key.upper(): value for key, value in zip(item, prize)}
```

其中 `item` 和 `prize` 是已确定的列表对象，`zip()` 函数用于打包两个列表。如果两个列表的元素数量不同，则以较短的为准。

---

# 元组

元组与列表相似，但使用小括号表示，特点是有序且不可变。如果元组中的元素是可变对象，则可以修改这些对象的内部数据，但不能改变元组本身。

#### 特点

*   有序的不可变对象。
    
*   元素不可以改变，但如果元素是可变对象（如列表），则可以改变元素内部的数据。
    

#### 示例

```python
t = (123, 456, [789, 456])
t[2].append(852)  # 修改列表元素
```

由于不可变性，元组没有生成式。

#### 创建方式

1.  直接用小括号赋值：
    

```python
t = ('123', '456', '789')
```

也可以不写小括号：

```python
t = '123', '456', '789'
```

2.  使用内置函数 `tuple()`：
    

```python
t = tuple(('123', '456', '789'))
```

注意：如果只有一个元素，必须加上逗号，否则不是元组：

```python
single_element_tuple = ('123',)
```
---

### 集合

集合是无序且可变的序列，相当于没有值的字典，使用 `{}` 表示，并对其中元素使用哈希函数计算位置。集合中的元素不能重复。

#### 特点

*   无序的可变序列。
    
*   元素不能重复。
    

#### 创建方式

1.  直接用 `{}` 赋值：
    

```python
s = {12, 34, 56}
```

2.  使用内置函数 `set()`：
    

```python
s = set(range(5))  # 将范围转为集合
s = set([12, 3, 4, 5])  # 将列表转为集合
s = set((12, 34, 56))  # 将元组转为集合
s = set('python')  # 将字符串转为集合
```

定义空集合时只能用 `set()`，否则会变成字典：

```python
empty_set = set()
```

#### 判断元素存在

使用 `in` 和 `not in` 判断元素是否存在：

```python
12 in s  # 返回 False 或 True
```

#### 增添元素

1.  使用 `add()` 方法，一次只能添加一个元素：
    

```python
s.add(741)
```

2.  使用 `update()` 方法，一次添加多个元素：
    

```python
s.update({741, 852, 963})
```

#### 移除元素

1.  使用 `remove()` 方法，一次删除一个指定元素：
    

```python
s.remove(12)
```

使用 `remove()` 时必须保证元素存在，否则会报错 `KeyError`。

2.  使用 `discard()` 方法，一次删除一个指定元素：
    

```python
s.discard(12)
```

使用 `discard()` 时即使指定元素不存在也不会报错。

3.  使用 `pop()` 方法，随机删除一个元素：
    

```python
s.pop()
```

4.  使用 `clear()` 方法，清空集合：
    

```python
s.clear()
```

#### 比较集合

1.  两个集合是否相等，使用 `==` 和 `!=`：
    

```python
s1 == s2  # 元素相等则集合相等
```

2.  一个集合是否是另一个的子集，使用 `issubset()`：
    

```python
s1.issubset(s2)  # 返回 True 或 False
```

3.  一个集合是否是另一个的超集，使用 `issuperset()`：
    

```python
s1.issuperset(s2)  # 返回 True 或 False
```

4.  两个集合是否有交集，使用 `isdisjoint()`：
    

```python
s1.isdisjoint(s2)  # 有交集返回 False，否则返回 True
```

#### 数学操作

1.  求交集：
    

```python
s1.intersection(s2)  # 或 s1 & s2
```

2.  求并集：
    

```python
s1.union(s2)  # 或 s1 | s2
```

3.  求差集：
    

```python
s1.difference(s2)  # 或 s1 - s2
```

4.  求对称差集：
    

```python
s1.symmetric_difference(s2)  # 或 s1 ^ s2
```

以上操作均不会改变原集合，只会创建新集合。

#### 集合生成式

使用集合生成式创建集合：

```python

{s for s in range(10)}  # 类似于列表生成式，只是将 [ ] 换成 {}

```

![image](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/6ef9eb25b0bb464c8b670a52593083f2/image.png)

---

# 字符串

#### 驻留机制

Python 中的字符串具有驻留机制，即相同的不可变字符串只保存一份，多个对象被赋予同样字符串时，这些对象指向相同的内存地址，不会创建多次，节省内存。

拼接字符串和修改字符串会影响性能，建议使用 `join()` 方法进行拼接，避免频繁新建对象。

#### 拼接方法

```python
'*'.join(t)  # 将列表或元组中的字符串用 * 连接
```

#### 查询方法

1.  `index()` 查找第一次出现的索引，若不存在则抛出 `ValueError`。
    
2.  `rindex()` 查找最后一次出现的索引，若不存在则抛出 `ValueError`。
    
3.  `find()` 查找第一次出现的索引，若不存在则返回 `-1`。
    
4.  `rfind()` 查找最后一次出现的索引，若不存在则返回 `-1`。
    

建议使用 `find()`，不会抛异常报错。

#### 大小写转换

*   `upper()`：全部转大写。
    
*   `lower()`：全部转小写。
    
*   `swapcase()`：小写的转大写，大写的转小写。
    
*   `title()`：把每个单词的首字母大写，其余转小写。
    
*   `capitalize()`：把第一个字符转大写，其他转小写。
    

#### 内容对齐

*   `center(width, fillchar)`：居中对齐，`width` 指定宽度，`fillchar` 指定填充字符，默认为空格。
    
*   `ljust(width, fillchar)`：左对齐。
    
*   `rjust(width, fillchar)`：右对齐。
    
*   `zfill(width)`：右对齐，用 0 填充。
    

#### 劈分方法

1.  `split(sep=None, maxsplit=-1)`：从左边开始劈分，默认以空格为分隔符，返回值为列表。
    
2.  `rsplit(sep=None, maxsplit=-1)`：从右边开始劈分。
    

#### 判断方法

*   `isidentifier()`：判断字符串是否是指定标识符。
    
*   `isspace()`：判断是否由空白字符组成。
    
*   `isalpha()`：判断是否全部由字母组成。
    
*   `isdecimal()`：判断是否全由十进制数字组成。
    
*   `isnumeric()`：判断是否是数字（包括所有类型的数字，如汉字）。
    
*   `isalnum()`：判断是否全部由字母和数字组成。
    

#### 替换方法

```python
s.replace(old, new, count=None)
```

替换后原字符串不发生改变，创建新的字符串。

#### 比较方法

使用运算符 `>`, `>=`, `<`, `<=`, `==`, `!=` 比较字符串。比较规则是从第一个字符开始逐一比较，直到遇到不同的字符为止，比较依据是字符的 ASCII 码值。

#### 切片方法

与列表切片类似，根据索引位置进行切片，生成新字符串：

```python
s[start:stop:step]
```

#### 格式化字符串

1.  使用 `%` 作占位符：
    

```python
'我叫%s,今年%d岁了' % ('张三', 18)
```

2.  使用 `{}` 作占位符：
    

```python
'我叫{},今年{}岁了'.format('张三', 18)
```

![image.png](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/d61c4cdf89514baf9f576bbf5c8709ae/image.png)

{0:.3} 表示保留三位有效数字。

{0:.3f} 表示保留三位小数，其中 `0` 是索引为 0 的字符串。

{0:10.3f} 表示保留三位小数，并且输出宽度为 10。

### f-string 方法

示例：`f'我叫{name}，今年{age}岁'`

# 编码转换

编码转换用于将字符串编码为二进制数据（bytes），以便在网络中传输到其他计算机，然后再解码回字符串。

#### 编码

将字符串转换为二进制数据（bytes）：

*   示例：`s.encode(encoding='GBK')` 使用 GBK 编码格式。
    
*   示例：`s.encode(encoding='UTF-8')` 使用 UTF-8 编码格式。
    

#### 解码

将二进制数据转换为字符串：

*   示例：`byte.decode(encoding='GBK')`，其中 `byte` 表示要解码的二进制数据。
    

# 函数

函数是封装好的、能够实现特定功能的代码集合。

#### 函数创建

```python
def 函数名(输入参数):
    函数体
    [return xxx]
```

上述格式称为函数定义式。

**示例：**

```python
def calc(a, b):  # calc 是函数名，a 和 b 是形式参数
    c = a + b  # 函数体，执行指定操作
    return c  # 返回计算结果
```

调用示例：

```python
x = calc(2, 3)  # 将 2 赋给 a，3 赋给 b
# 运行后 x = 2 + 3 = 5，即 x = 5
```

#### 参数传递

##### 形式参数与实际参数

*   **形式参数（形参）**：在函数定义时声明的参数，如 `calc` 中的 `a` 和 `b`。
    
*   **实际参数（实参）**：调用函数时传入的具体值，如 `calc(2, 3)` 中的 `2` 和 `3`。
    

##### 位置实参

按位置顺序将实参传递给形参。例如：

```python
x = calc(2, 3)  # 2 对应 a，3 对应 b
```

##### 关键字实参

通过关键字指定实参，不依赖位置顺序。例如：

```python
x = calc(b=2, a=3)  # 此时 a 为 3，b 为 2
```

如果使用了关键字参数，则后续参数必须也使用关键字形式。

#### 参数变化

当传递不可变对象（如整数、字符串）作为实参时，函数体内的修改不会影响原始实参；而传递可变对象（如列表、字典）时，函数体内的修改会影响原始实参。

原因在于 Python 中的参数传递是对参数引用的传递。对于不可变对象，修改会创建新的对象，而对于可变对象，修改会影响原对象。

#### 返回值

1.  如果函数没有返回值，则可以省略 `return`。
    
2.  如果返回单个值，则直接返回该值。
    
3.  如果返回多个值，则以元组的形式返回。
    

#### 参数定义

##### 默认值参数

定义时给形参设置默认值，只有当调用时未提供实参时才使用默认值。

**注意**：带有默认值的参数后面不能再有无默认值的参数。

##### 可变数量的位置参数和关键字参数

*   **可变位置参数**：在形参前加 `*`，接收任意数量的位置参数，结果为元组。
    

```python
def fun(*args):
    print(args)
```

*   **可变关键字参数**：在形参前加 `**`，接收任意数量的关键字参数，结果为字典。
    

```python
def fun(**kwargs):
    print(kwargs)
```

当同时存在可变位置参数和可变关键字参数时，位置参数必须位于关键字参数之前。

##### 强制使用关键字实参

通过在参数列表中使用 `*` 分隔符，使某些参数只能通过关键字传递。

```python
def fun(a, b, *, c, d):
    pass
```

#### 变量作用域

*   **局部变量**：仅在函数内部有效，可通过 `global` 声明使其变为全局变量。
    
*   **全局变量**：在函数外部定义，可在函数内外使用。
    

#### 递归函数

递归函数是指在函数体内调用自身。递归函数通常包含递归调用和递归终止条件。

递归调用过程：

*   每次递归调用都会在栈内分配一个栈帧。
    
*   每次函数执行完毕后，相应的栈帧会被释放。
    

递归的优点是代码简洁易懂，但缺点是占用内存较多，效率较低。

#### 斐波那契数列

斐波那契数列为：1, 1, 2, 3, 5, 8... 其中前两项为 1，后续每一项是前两项之和。

# 错误处理

##### 思路不清

遇到复杂逻辑或嵌套结构时，可以通过 `print()` 输出当前变量值，逐步调试程序。

##### try-except 结构

用于处理程序中的异常情况。

**基本结构：**

```python
try:
    # 正常代码
except ExceptionType:
    # 处理异常
```

**多重 except：**

```python
try:
    n1 = int(input('请输入一个整数'))
    n2 = int(input('请输入第二个整数'))
    result = n1 / n2
    print(result)
except ValueError:
    print('对不起，只能输入整数')
except ZeroDivisionError:
    print('对不起，除数不能为零')
except BaseException as e:
    print(f'发生错误: {e}')
```

**try-except-else-finally：**

```python
try:
    n1 = int(input('请输入一个整数'))
    n2 = int(input('请输入第二个整数'))
    result = n1 / n2
except ValueError:
    print('对不起，只能输入整数')
except ZeroDivisionError:
    print('对不起，除数不能为零')
else:
    print(f'结果为: {result}')
finally:
    print('无论是否出错，此部分都会执行')
```

#### 常见异常类型

*   `ZeroDivisionError`: 除零错误
    
*   `IndexError`: 序列索引超出范围
    
*   `KeyError`: 映射中不存在指定键
    
*   `NameError`: 未声明/初始化对象
    
*   `SyntaxError`: Python 语法错误
    
*   `ValueError`: 传入无效参数
    

#### 使用 traceback 打印异常信息

```python
import traceback

try:
    num = 10 / 0
except:
    traceback.print_exc()
```

以上内容涵盖了 Python 函数的基本概念、参数传递、返回值、变量作用域、递归函数及异常处理等内容。

![image.png](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/bf4c83d79da246789afb562c937afbd8/image.png)

# 类

类是Python中的一种数据类型，用于创建自定义的数据结构。以下是关于类的详细说明：

### 类的创建

可以通过自定义来创建一个类。示例如下：

```python
class Student:  # 其中Student为类的名称
    pass  # pass处写类的内容
```

### 类名规范

类名由一个或多个单词组成，每个单词的首字母大写（即使用驼峰命名法）。

### 类的组成

类包含以下组成部分：

*   **类属性**：直接定义在类中的变量。
    
*   **实例方法**：在类中定义的函数，默认接收实例对象作为第一个参数（通常是`self`）。
    
*   **静态方法**：使用`@staticmethod`修饰的方法，不接收隐含的第一个参数。
    
*   **类方法**：使用`@classmethod`修饰的方法，默认接收类本身作为第一个参数（通常是`cls`）。
    

### 初始化方法 (`__init__`)

初始化方法用于在创建对象时进行赋值操作，将局部变量赋给实例属性。

示例：

```python
class Student:
    age = '18'  # 类属性
    
    def __init__(self, name, age):  # 这里的name和age为局部变量
        self.name = name  # self.name表示实例属性
        self.age = age  # 实例属性
        
    def eat(self):  # 括号中通常填self
        print('实例方法')
    
    @staticmethod  # 用这个修饰的是静态方法
    def sm():  # 静态方法括号中不允许填东西
        print('静态方法')
    
    @classmethod  # 用classmethod修饰的是类方法
    def cm(cls):  # 类方法中括号要写cls
        print('类方法')
```

### 对象的创建

对象的创建也称为类的实例化，格式如下：

```python
实例名 = 类名()
```

通过类对象创建的对象称为实例对象。例如：

```python
stu = Student('张三', 18)  # 创建名为stu的实例对象
print(stu.name)  # 调用实例属性
stu.eat()  # 调用实例方法
```

调用类中属性或方法的格式为：`实例对象名.方法（属性）名`。也可以使用另一种方式：`类名.方法名(实例对象名)`。例如：

```python
student.eat(stu)  # 与第一种等价
```

### 输出对象

如果直接用`print()`输出实例对象，会返回所属的类以及整个对象的十六进制内存地址。

### 类属性

类属性是在类中方法之外定义的变量，被该类的所有实例共享。当类属性被修改时，所有实例都会受到影响。

### 实例方法

实例方法使用时需要传入实例，默认参数为类的实例对象（通常是`self`），可以使用实例名或类名调用。

### 类方法

类方法调用时不需要传入实例，默认参数为类本身（通常是`cls`），用类名调用。例如：

```python
Student.cm()  # 括号中不需要传入参数
```

### 静态方法

静态方法调用时不需要传入实例，也没有默认参数，用类名调用。例如：

```python
Student.sm()
```

### 动态绑定属性

可以将一个属性单独绑定给某个类的实例对象，这样的属性只为该实例对象所有，其他实例无法调用。例如：

```python
stu1.gender = '女'  # 为stu1单独绑定一个gender属性
```

### 动态绑定方法

可以先创建一个函数，然后将其绑定到指定的实例。当这个函数被绑定到一个实例后，其他未绑定的实例就无法调用。例如：

```python
def show():
    print('定义在类之外的函数')

stu1.show = show  # 将函数show绑定为stu1的show方法
```

# 面向对象编程

面向对象是一种与面向过程相对的编程思想。面向对象注重方法的调用，而面向过程则更关注方法内部的具体步骤。

#### 三大特征：封装、继承、多态

##### 封装

封装可以提高程序的安全性。它将数据（属性）和行为（方法）包装到类对象中。在类外部直接调用方法与结果时，无需关心内部的具体实现细节，从而隔离了复杂度。例如，类中的实例方法只要在类对象中定义，创建该类的实例对象后就能直接调用这些方法。

**属性私有** Python 中没有严格的类对象私有机制。若要阻止实例对象访问某个类属性，可以在属性名前加两个下划线（`__`）。此时，实例对象仍可通过 `_<类名>__<属性名>` 访问，但无法直接使用原属性名。这依赖于程序员的自觉遵守。

##### 继承

继承提高了程序的复用性。子类可以继承父类的属性和方法，Python 支持多父类继承。如果没有显式指定父类，默认为 `object` 类。通过 `super()` 可以调用父类中的属性和方法。

*   **格式**：
    

**方法重写** 当从父类继承的方法和属性不能满足子类的需求时，可以通过重写方法或属性来扩展功能。在子类中编写同名方法即可重写父类方法，并可在重写的方法中引用父类方法，实现在原有基础上添加子类特有的功能。

```python
def info(self):  # 使用与父类相同的方法名
    super().info()  # 调用父类方法
    print(self.stu_no)  # 添加子类独有的方法
```

##### 多态

多态意味着即使不知道一个变量所引用的对象类型，仍然可以通过这个变量调用方法，在运行过程中根据所引用对象的类型动态决定调用哪个对象中的方法。

**鸭子类型** 鸭子类型是指当看到一只鸟走起来像鸭子、叫起来像鸭子，就可以认为它是鸭子。在鸭子类型中，不关心对象的实际类型，只关心其行为。动态语言的多态崇尚鸭子类型，而静态语言实现多态通常需要明确的继承关系、方法重写和父类引用指向子类对象（如 Java）。

#### 特殊属性和方法

特殊属性以双下划线开头或结尾。常见的特殊属性包括：

*   `__dict__`：获取对象的属性和方法字典。
    
*   `__class__`：获取对象所属的类。
    
*   `__bases__`：获取对象的父类组成的元组。
    
*   `__base__`：获取距离对象最近的父类（即继承时的第一个父类）。
    
*   `__mro__`：获取对象的父类层次结构。
    
*   `__subclasses__()`：获取子类列表。
    

特殊方法用于实现特定操作：

*   `__add__`：运算符 `+` 的底层方法，可通过重写实现自定义相加效果。
    
*   `__len__`：对应内置函数 `len()`，输出指定对象的长度。
    
*   `__new__`：创建新对象并返回。
    
*   `__init__`：初始化对象参数。
    

#### 变量赋值、浅拷贝与深拷贝

*   **变量赋值**：将一个对象赋给两个变量，实际上还是只有一个对象，两个变量都指向同一个对象的 ID。
    
*   **浅拷贝**：使用 `copy.copy()` 进行浅拷贝，仅复制对象本身，不复制其包含的子对象，因此源对象与拷贝所得对象共享子对象。
    
*   **深拷贝**：使用 `copy.deepcopy()` 进行深拷贝，拷贝所得的对象及其子对象都是新建的，指向新的 ID。
    

```python
import copy
a = copy.copy(obj)  # 浅拷贝
b = copy.deepcopy(obj)  # 深拷贝
```

### 模块

模块是一个包含各种函数、类和语句的代码文件，同时也作为一种数据类型存在，名为 `module`。模块化编程的优点包括便于维护、便于团队合作和避免变量名重复。

#### 导入模块

*   **导入整个模块**：`import 模块名称`
    
*   **导入指定内容**：`from 模块名称 import 函数/变量/类`
    

如果要导入的自定义模块不在当前工作目录中，需先将模块所在路径添加到工作区，使用 `sys` 模块查看和添加路径。

```python
import sys
sys.path.append('J:\\python\\文件')  # 添加路径
```

#### 主程序方式运行

每个模块中都有一个记录模块名称的变量 `__name__`。如果模块不是被导入到其他程序中执行，则它可能是解释器的顶级模块，顶级模块的 `__name__` 值为 `__main__`。通过检查 `__name__` 可以确保模块以主程序方式运行时才执行某些代码。

```python
if __name__ == '__main__':
    print('以主程序运行')
```

#### 包

包是用于存放模块的文件夹，在包中必须有一个 `__init__.py` 文件，普通目录则不需要。使用包可以避免模块名冲突，将功能相似的模块放入一个包中。

```python
import package.module_A  # 导入包中的模块
import package.module_A as a  # 为模块赋予简易名称
```

#### 在线安装模块

在命令行中使用 `pip install + 模块名` 来在线安装模块。

```bash
pip install schedule  # 安装 schedule 模块
```

### 常用模块

*   **sys**：与 Python 解释器及其环境操作相关的标准库，可调用对象内存大小、工作路径等信息。
    
*   **time**：提供与时间相关的各种函数。
    
*   **os**：提供访问操作系统服务的标准库。
    
*   **calendar**：提供与日期相关的各种函数。
    
*   **urllib**：用于获取来自网上（服务器）的数据（常用于爬虫）。
    
*   **json**：用于 JSON 序列化和反序列化对象（常用于爬虫）。
    
*   **re**：用于在字符串中执行正则表达式匹配和替换。
    
*   **math**：提供标准算术运算函数。
    
*   **decimal**：用于进行精确控制运算精度、有效数位和四舍五入操作的十进制运算。
    
*   **logging**：提供灵活的记录事件、错误和调试信息等日志信息的功能。
    

# 编码格式

常见的编码格式包括：ASCII、ISO 8859-1、GBK、GB18030 和 UTF-8。

#### Unicode

*   Unicode 与 ISO 8859-1 不兼容。
    
*   UTF-8 是 Unicode 的一种实现方式。
    
*   GBK 和 GB18030 是中文字符的编码格式。
    

#### Python 文件编码

*   Python 解释器在内存中使用 Unicode。
    
*   `.py` 文件在磁盘上默认使用 UTF-8 编码存储（外存）。
    
*   可以通过在文件开头添加 `# -*- coding: <encoding> -*-` 来修改文件编码格式。
    

### 不同编码格式的区别

*   在不同编码格式下，某些字符可能会出现乱码。
    
*   相同内容的文件大小也可能不同。
    

# 文件的读写

#### 数据流

文件的读写通常称为 I/O（输入/输出），也称为数据流。通过 I/O 流将磁盘文件的内容与程序中的对象内容进行同步。

#### 创建文件对象

使用内置函数 `open()` 创建文件对象：

```python
file = open('filename', 'mode')
```

创建完成后，对 `file` 的操作会同步到磁盘中的文件。

#### 读取文件对象

*   `file.readlines()`：将每一行文字作为一个字符串放入列表。
    
*   `file.readline()`：只读取一行。
    

#### 关闭文件对象

使用 `file.close()` 关闭文件对象。

### 文件类型

#### 文本文件

*   存储普通字符，默认使用 Unicode 字符集，可以使用记事本打开。
    

#### 二进制文件

*   将数据内容以字节形式存储，无法用记事本打开，必须使用专用软件打开。例如：MP3 音频文件、JPG 图片、DOC 文档等。这种文件打开时必须使用二进制模式。
    

### 常用文件打开模式

*   `r`：只读模式（默认）。
    
*   `w`：写入模式，如果文件存在则覆盖。
    
*   `a`：追加模式，在文件末尾追加内容。
    
*   `b`：二进制模式，常与 `r`、`w`、`a` 组合使用，如 `rb`、`wb`、`ab`。
    
*   `+`：读写模式，常与 `r`、`w`、`a` 组合使用，如 `r+`、`w+`、`a+`。
    

![image](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/89a6a9f19b8a46a9a6b7f494e06acfa9/image.png)

![image.png](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/aa235d89b3f34359abf82b02b0825bb0/image.png)

文件对象的常用方法：

*   `read(size)`：从文件中读取指定数量的字节或字符。若省略 `size` 参数，则读取至文件末尾，即一次性读取文件的所有内容。
    
*   `readline()`：从文本文件中读取一行内容。
    
*   `readlines()`：将文件中的每一行文字作为一个字符串放入列表。
    
*   `write(str)`：将字符串 `str` 写入文件。
    
*   `writelines(list)`：将字符串列表写入文本文件，注意该方法不会自动添加换行符。
    
*   `seek(offset, whence=0)`：把文件指针移动到新的位置。`offset` 表示相对于 `whence` 的位移量：
    
    *   正数表示向文件末尾方向移动；
        
    *   负数表示向文件开头方向移动。
        

`whence` 参数的不同值代表不同的起始位置：

*   `0`（默认值）：从文件头开始计算；
    
*   `1`：从当前位置开始计算；
    
*   `2`：从文件尾开始计算。
    

**注意**：`offset` 参数的值代表的是字节数。例如，一个中文字符占两个字节，因此如果需要移动一个中文字符的位置，应填入 `2` 而非 `1`，否则会导致错误。

### `with` 语句

```python
with open('word', 'a+') as file:
    # 文件操作代码
```

`with` 语句后的部分称为上下文管理器。使用这种语句可以避免手动关闭文件，确保文件在操作完成后自动关闭。

#### 上下文管理协议

上下文管理协议是指能够自动完成打开/进入和关闭/退出的特殊方法。符合此协议的对象被称为上下文管理器。即使在执行过程中发生异常，上下文管理器也会确保执行结束语句，如文件读写中的 `__exit__()` 方法。

![image.png](https://qianwen.alicdn.com/note/05f51d9bb307619d06eb41f38b782733/QaRtGJWagZAspta7/5ef8fe7db0ee46c599f4fcc96d7ef958/image.png)

### os 模块

`os` 模块是与操作系统功能和文件系统相关的模块，大多数语句都与操作系统有关，在不同操作系统上运行可能会得到不同的结果，功能十分强大。

#### 操作系统相关函数：

*   `system(command)`：调用系统命令，打开系统的应用程序。括号内填写命令。
    
*   `startfile(path)`：直接调用可执行文件，括号中填写文件路径。
    

#### 操作目录相关函数：

*   `getcwd()`：返回当前的工作目录。
    
*   `listdir(path)`：返回指定路径下的文件和目录信息，默认从当前文件所处目录中寻找；若在上级目录，应在前面加上 `../`。
    
*   `mkdir(path)`：在当前文件的目录下创建新的目录。
    
*   `makedirs(path)`：在当前文件目录下创建多级目录。
    
*   `rmdir(path)`：删除空目录。
    
*   `removedirs(path1/path2...)`：递归删除多级空目录。
    
*   `chdir(path)`：设置指定目录为工作目录。
    

#### os.path 模块：用于操作路径

`os.path` 模块提供了许多用于操作路径的函数：

*   `abspath(path)`：获取文件或目录的绝对路径。
    
*   `exists(path)`：判断文件或目录是否存在，如果存在返回 `True`，否则返回 `False`。
    
*   `join(path, *paths)`：将多个路径拼接成一个完整的路径。
    
*   `splitext(path)`：分离文件名和扩展名。
    
*   `basename(path)`：从路径中提取文件名。
    
*   `dirname(path)`：从路径中提取目录部分，不包括文件名。
    
*   `isdir(path)`：判断给定路径是否为目录。
    

#### `walk()` 方法：

`walk(top, topdown=True, onerror=None, followlinks=False)` 是 `os` 模块中的一个方法，可以递归遍历指定文件夹中的所有文件和目录及其路径。使用这个方法返回的是一个三元组 `(dirpath, dirnames, filenames)`，不能直接打印输出，需要通过循环遍历每个元素。该方法可以方便地获取文件和目录的信息。